{
  "name": "AMA Reset NIP - Smoke Tests (Subworkflow)",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "node-rn-smoke-trigger",
      "name": "Trigger Smoke",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const fromTrigger = ($items('Trigger Smoke', 0, 0)?.[0]?.json) || null;\nconst fromInput = $input.first()?.json || null;\nconst input = fromTrigger || fromInput || {};\n\nif (!fromTrigger && !fromInput) {\n  return [{\n    json: {\n      ok: false,\n      error: 'Smoke config not received from runner. Ejecuta desde el workflow runner (Manual Trigger -> Smoke Config Inputs).',\n      debug: {\n        hasFromTrigger: false,\n        hasFromInput: false,\n      },\n      results: [],\n    },\n  }];\n}\n\nconst asBool = (v, def = false) => {\n  if (typeof v === 'boolean') return v;\n  if (typeof v === 'string') {\n    const t = v.trim().toLowerCase();\n    if (t === 'true') return true;\n    if (t === 'false') return false;\n  }\n  if (typeof v === 'number') return v !== 0;\n  return def;\n};\n\nconst baseUrl = String(input.baseUrl || 'https://reset.amatracksafe.com.mx').replace(/\\/+$/, '');\nconst originForNipReset = String(input.originForNipReset || 'https://amatracksafe.com.mx').trim();\nconst runPositiveLookup = asBool(input.runPositiveLookup, false);\nconst runSendLink = asBool(input.runSendLink, false);\n\nconst validEmail = String(input.validEmail || '').trim().toLowerCase();\nconst validWhatsappId = String(input.validWhatsappId || '').trim();\nconst validVehiculoId = String(input.validVehiculoId || '').trim();\n\nconst results = [];\n\nfunction push(step, pass, extra = {}) {\n  results.push({ step, pass, ...extra });\n}\n\nfunction getHttpClient() {\n  if (typeof $httpRequest === 'function') return $httpRequest;\n  if (typeof this !== 'undefined' && this.helpers && typeof this.helpers.httpRequest === 'function') {\n    return this.helpers.httpRequest.bind(this.helpers);\n  }\n  return null;\n}\n\nconst httpClient = getHttpClient();\n\nif (!httpClient) {\n  return [{ json: { ok: false, error: 'No HTTP helper available in this n8n runtime.' } }];\n}\n\nasync function request(method, pathOrUrl, opts = {}) {\n  const isAbsolute = /^https?:\\/\\//i.test(pathOrUrl);\n  const url = isAbsolute ? pathOrUrl : `${baseUrl}${pathOrUrl}`;\n  const allow = opts.allowStatus || [];\n\n  const defaultHeaders = {\n    'Content-Type': 'application/json',\n    ...(url.includes('/nip-reset/') ? { Origin: originForNipReset } : {}),\n  };\n\n  const req = {\n    method,\n    url,\n    headers: {\n      ...defaultHeaders,\n      ...(opts.headers || {}),\n    },\n    json: true,\n    returnFullResponse: true,\n    ignoreHttpStatusErrors: true,\n    timeout: 30000,\n  };\n\n  if (opts.body !== undefined) req.body = opts.body;\n\n  try {\n    const resp = await httpClient(req);\n    const status = Number(resp?.statusCode ?? resp?.status ?? 200);\n    const data = Object.prototype.hasOwnProperty.call(resp || {}, 'body') ? resp.body : resp;\n    if (status >= 400 && !allow.includes(status)) {\n      throw new Error(`HTTP ${status} ${method} ${url} -> ${JSON.stringify(data)}`);\n    }\n    return { status, data, url };\n  } catch (err) {\n    const status = Number(\n      err?.statusCode ??\n      err?.response?.statusCode ??\n      err?.response?.status ??\n      0\n    );\n    const data = err?.response?.body ?? err?.response?.data ?? { message: err.message || String(err) };\n    if (allow.includes(status)) return { status, data, url };\n    throw new Error(`HTTP ${status} ${method} ${url} -> ${JSON.stringify(data)}`);\n  }\n}\n\ntry {\n  const health = await request('GET', '/api/health');\n  push('health', health.status === 200 && health.data?.ok === true, { status: health.status, response: health.data });\n\n  const fakeEmail = `smoke-${Date.now()}@test.local`;\n  const lookupInvalid = await request('POST', '/nip-reset/lookup', {\n    body: { email: fakeEmail, whatsapp_id: '5511111111' },\n    allowStatus: [404, 429],\n  });\n\n  const lookupInvalidPass =\n    (lookupInvalid.status === 404 && lookupInvalid.data?.message === 'Datos incorrectos') ||\n    lookupInvalid.status === 429;\n\n  push('lookup_invalid', lookupInvalidPass, {\n    status: lookupInvalid.status,\n    response: lookupInvalid.data,\n    rateLimited: lookupInvalid.status === 429,\n    reason: lookupInvalid.status === 429 ? 'lookup_rate_limited' : null,\n  });\n\n  const tokenShort = await request('GET', '/nip-reset/token-info?token=abc', { allowStatus: [400] });\n  push('token_info_short_token', tokenShort.status === 400, { status: tokenShort.status, response: tokenShort.data });\n\n  const invalidLongToken = 'x'.repeat(40);\n  const tokenInvalid = await request('GET', `/nip-reset/token-info?token=${encodeURIComponent(invalidLongToken)}`, {\n    allowStatus: [403],\n  });\n  push(\n    'token_info_invalid_token',\n    tokenInvalid.status === 403 && tokenInvalid.data?.message === 'Liga inválida o expirada.',\n    { status: tokenInvalid.status, response: tokenInvalid.data }\n  );\n\n  const confirmMismatch = await request('POST', '/nip-reset/confirm', {\n    body: { token: 'y'.repeat(40), nip: '1234', nipConfirm: '9999' },\n    allowStatus: [400, 429],\n  });\n\n  const confirmMismatchPass = confirmMismatch.status === 400 || confirmMismatch.status === 429;\n  push('confirm_mismatch', confirmMismatchPass, {\n    status: confirmMismatch.status,\n    response: confirmMismatch.data,\n    rateLimited: confirmMismatch.status === 429,\n    reason: confirmMismatch.status === 429 ? 'confirm_rate_limited' : null,\n  });\n\n  const confirmInvalid = await request('POST', '/nip-reset/confirm', {\n    body: { token: 'z'.repeat(40), nip: '1234', nipConfirm: '1234' },\n    allowStatus: [403, 429],\n  });\n  const confirmInvalidPass =\n    (confirmInvalid.status === 403 && confirmInvalid.data?.message === 'Liga inválida o expirada.') ||\n    confirmInvalid.status === 429;\n\n  push('confirm_invalid_token', confirmInvalidPass, {\n    status: confirmInvalid.status,\n    response: confirmInvalid.data,\n    rateLimited: confirmInvalid.status === 429,\n    reason: confirmInvalid.status === 429 ? 'confirm_rate_limited' : null,\n  });\n\n  if (runPositiveLookup) {\n    if (!validEmail || !/^\\d{10}$/.test(validWhatsappId)) {\n      push('lookup_valid', false, {\n        reason: 'Faltan validEmail/validWhatsappId para prueba positiva',\n      });\n    } else {\n      const lookupValid = await request('POST', '/nip-reset/lookup', {\n        body: { email: validEmail, whatsapp_id: validWhatsappId },\n        allowStatus: [200, 404, 429],\n      });\n\n      const isValidLookup =\n        (lookupValid.status === 200 &&\n          lookupValid.data?.ok === true &&\n          ['confirmar_vehiculo_unico', 'seleccionar_vehiculo'].includes(lookupValid.data?.step) &&\n          Array.isArray(lookupValid.data?.vehiculos) &&\n          lookupValid.data.vehiculos.length > 0) ||\n        lookupValid.status === 429;\n\n      push('lookup_valid', isValidLookup, {\n        status: lookupValid.status,\n        response: lookupValid.data,\n        rateLimited: lookupValid.status === 429,\n        reason: lookupValid.status === 429 ? 'lookup_rate_limited' : null,\n      });\n\n      if (lookupValid.status === 200 && lookupValid.data?.ok === true) {\n        if (runSendLink) {\n          const vehiculos = lookupValid.data.vehiculos;\n          const selected = (validVehiculoId ? vehiculos.find(v => v.vehiculoId === validVehiculoId) : null) || vehiculos[0];\n\n          const sendLink = await request('POST', '/nip-reset/send-link', {\n            body: {\n              email: validEmail,\n              whatsapp_id: validWhatsappId,\n              cliente_id: lookupValid.data.cliente_id,\n              vehiculoId: selected.vehiculoId,\n            },\n            allowStatus: [200, 404, 429],\n          });\n\n          const passSend = sendLink.status === 200 || sendLink.status === 429;\n          push('send_link_valid', passSend, {\n            status: sendLink.status,\n            selectedVehiculoId: selected.vehiculoId,\n            response: sendLink.data,\n            rateLimited: sendLink.status === 429,\n            reason: sendLink.status === 429 ? 'send_link_rate_limited' : null,\n          });\n        } else {\n          push('send_link_valid', true, { skipped: true, reason: 'runSendLink=false' });\n        }\n      } else {\n        push('send_link_valid', true, { skipped: true, reason: 'lookup_valid no pasó' });\n      }\n    }\n  } else {\n    push('lookup_valid', true, { skipped: true, reason: 'runPositiveLookup=false' });\n    push('send_link_valid', true, { skipped: true, reason: 'runPositiveLookup=false' });\n  }\n\n  const passed = results.filter(r => r.pass).length;\n  const failed = results.filter(r => !r.pass).length;\n\n  return [{\n    json: {\n      ok: failed === 0,\n      summary: { total: results.length, passed, failed },\n      configUsed: {\n        baseUrl,\n        originForNipReset,\n        runPositiveLookup,\n        runSendLink,\n        validEmail: validEmail || null,\n        validWhatsappId: validWhatsappId || null,\n        validVehiculoId: validVehiculoId || null,\n        inputSource: fromTrigger ? 'trigger' : 'input',\n      },\n      results,\n    },\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ok: false,\n      error: String(e?.message || e),\n      configUsed: {\n        baseUrl,\n        originForNipReset,\n        runPositiveLookup,\n        runSendLink,\n        validEmail: validEmail || null,\n        validWhatsappId: validWhatsappId || null,\n        validVehiculoId: validVehiculoId || null,\n        inputSource: fromTrigger ? 'trigger' : (fromInput ? 'input' : 'none'),\n      },\n      results,\n    },\n  }];\n}"
      },
      "id": "node-rn-run-smoke",
      "name": "Run Smoke Tests",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        300
      ]
    }
  ],
  "connections": {
    "Trigger Smoke": {
      "main": [
        {
          "node": "Run Smoke Tests",
          "type": "main",
          "index": 0
        }
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  }
}
